#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# selenium: Ansible module for Selenium

import signal
import urllib

from ansible.module_utils.basic import *

DOCUMENTATION = '''
module: selenium
short_description: Selenium Infrastructure
description:
  - The Description
version_added: "1.0"
options:
  role:
    description:
      - Which role should be ran
    required: true
    default: null
    choices:
      - "hub"
      - "node"

  state:
    description:
      - Which state the program should be in
    required: true
    default: present
    choices:
      - "running"
      - "stopped"

  java:
    description:
      - The path of the Java executable. You are able to specify the full path of the executable here.
        e.g. /usr/bin/java
    required: false
    default: 'java'

  logfile:
    description:
      - Where to log the output of the hub / node
    required: false
    default: './selenium.log

  version:
    description:
      - Which version of Selenium to bring down. This can be a branch name, commit hash, or actual version
      - May also be a release. e.g.: selenium-2.48.2
    required: false
    default: 'master'

  path:
    description:
      - Where to store and extract the selenium source
    required: false
    default: '.'

  force:
    description:
      - Force a redownload / restart of the hub/node
    required: false
    default: 'false'


'''

JAR_URL = 'http://selenium-release.storage.googleapis.com/%s/selenium-server-standalone-%s.jar'


def hub(module, state):
    """
    Hub tasks
    :param module: the module
    :param state:  the state
    :return:
    """

    (changed, jar_file) = download(module)
    if state == 'running':
        start(module, jar_file)
    elif state == 'stopped':
        stop(module)


def node(module, state):
    """
    Node tasks
    :param module: the module
    :param state: the state
    :return:
    """

    changed, jar_file = download(module)
    if state == 'running':
        start(module, jar_file)
    elif state == 'stopped':
        stop(module)


def is_running(module):
    """
    Whether or not the specific role in question is running right now.
    :param module:
    :return:
    """

    if not get_pid(module):
        return False
    else:
        return True


def get_pid(module):
    """
    Fetches the pid if it is running, for the role.
    :param module: the module
    :return:
    """

    role = module.params['role'].replace(".", "\\.")
    pid_cmd = ['pgrep', '-f', '.*selenium-server-%s.*%s' %
               (module.params['version'], role)]

    try:
        return int(subprocess.check_output(pid_cmd).rstrip())
    except subprocess.CalledProcessError:
        return False


def start(module, jar_file):
    """
    Start the jar
    :param module:
    :param jar_file: the abs path of the selenium-server-standalone jar
    :return:
    """

    changed = False
    role = module.params['role']

    if not is_running(module):
        changed = True
        args = ''
        if module.params['args']:
            for (k, v) in module.params['args']:
                args += '-%s=%s ' % (k, v)

        java_executable = os.path.abspath(os.path.expandvars(module.params['java']))
        log_file = os.path.abspath(os.path.expandvars(module.params['logfile']))

        cmd = "%s -jar %s -role %s %s >> %s 2>&1 &" % (java_executable,
                                                       jar_file,
                                                       role,
                                                       args,
                                                       log_file)

        rc = os.system(cmd)

        if rc != 0:
            abort(module, 'Running the %s role returned code %s !' % (role, rc))

    pid = get_pid(module)
    if pid:
        finish(module, msg='%s is running' % role, changed=changed, stdout=pid)
    else:
        abort(module, 'Couldnt fetch the pid of the running %s ! It may have ended abruptly.' % module.params['role'])


def stop(module):
    """
    Stop something
    :param module: the module
    :return:
    """

    changed = False
    pid = get_pid(module)

    if is_running(module):
        try:
            os.kill(pid, signal.SIGKILL)
            if not get_pid(module):
                changed = True
        except Exception as e:
            abort(module, 'Couldnt kill pid %s! Error was: %s' % (pid, e.message))

    finish(module, '%s is stopped' % (module.params['role']), changed=changed)


def download(module):
    """
    Download jar from downloads page
    :param module: the module
    :return:
    """

    changed = False

    full_version = module.params['version']
    (major, minor, patch) = full_version.split('.')

    url = JAR_URL % ((major + '.' + minor), full_version)
    jar_file = '%s/selenium-server-%s.jar' % (os.path.abspath(os.path.expanduser(module.params['path'])),
                                              full_version)

    if not os.path.exists(jar_file) or module.params['force']:  # download if not already downloaded
        try:
            urllib.urlretrieve(url, jar_file)
            changed = True
        except Exception as e:
            abort(module, "Couldn't download %s. Are you using a valid version? Error was: %s" %
                  (url, e.message))
    return changed, jar_file


def finish(m, msg='', stdout=None, changed=False):
    """
    Role is all down
    :param m: the module
    :param msg: the message
    :param stdout: the output of the program (to be used with register)
    :param changed: whether or not anything was changed
    :return:
    """
    if stdout:
        m.exit_json(changed=changed, msg=msg, stdout=stdout)
    else:
        m.exit_json(changed=changed, msg=msg)


def abort(m, msg):
    """
    Something wrong happened.. abort!
    :param m: the module
    :param msg: the message
    :return:
    """

    m.fail_json(msg=msg)


def main():
    """
    Main task / entry point
    :return:
    """

    module = AnsibleModule(
        argument_spec=dict(
            role=dict(required=True, choices=['hub', 'node'], default=None),
            state=dict(choices=['running', 'stopped'], default='running'),
            version=dict(default='2.42.2'),
            path=dict(default='.'),
            force=dict(default=False),
            args=dict(required=False, default=''),
            java=dict(required=False, default='/usr/bin/java'),
            logfile=dict(required=False, default='./selenium.log')
        ),

        supports_check_mode=True,

        mutually_exclusive=[]
    )

    role = module.params['role']
    state = module.params['state']

    if role == 'hub':
        hub(module, state)
    elif role == 'node':
        node(module, state)


main()
